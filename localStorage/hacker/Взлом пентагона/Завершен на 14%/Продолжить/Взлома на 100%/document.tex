\documentclass[a4paper, 11pt]{article}
\usepackage{mathtext} 
\usepackage[T2A]{fontenc} 
\usepackage[utf8]{inputenc} 
\usepackage[english,russian]{babel} 

\usepackage{graphicx} 
\usepackage{amsfonts,amssymb,amscd,amsmath,amsthm} 
\usepackage[unicode, pdftex]{hyperref}
\usepackage{caption}
\usepackage{floatrow}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{minted}
\usepackage{textcomp}
\usepackage{styles/TextElements}
\usepackage{styles/Colors}
\setlength{\parindent}{0pt}
\graphicspath{{images/}}
\DeclareGraphicsExtensions{.png}
\parindent=1cm
\tolerance-1

\newcommand{\assertiontype}[1]{{\large \bfseries #1}}

\begin{document}
	\begin{center}
		{\LARGE \bfseries Google-тесты}
	\end{center}

	\tableofcontents

	\newpage
	
	\section{Введение}
	
	{\bfseries Google Test} — это фреймворк от Google для юнит-тестирования кода на С++.
	
	Ключевым понятием в {\bfseries Google Test Framework} является понятие утверждения ({\itshape assert}). Утверждение представляет собой макрос, результатом выполнения которого может быть успех ({\itshape success}), некритический отказ ({\itshape nonfatal failure}) и критический отказ ({\itshape fatal failure}). Критический отказ вызывает завершение выполнения теста, в остальных случаях тест продолжается. Сам тест представляет собой набор макросов. Кроме того, тесты могут быть сгруппированы в наборы ({\itshape test case}). Если сложно настраиваемая группа объектов должна быть использована в различных тестах, можно использовать тестовые классы ({\itshape test fixture}). Объединенные наборы тестов являются тестовой программой.\\
	
	\section{Макросы}
	
	Макросы, порождающие в случае их ложности критические отказы начинаются с \cppinline{ASSERT_}, некритические — \cppinline{EXPECT_}. Следует иметь ввиду, что в случае критического отказа выполняется немедленный возврат из функции, в которой встретилось вызвавший отказ макрос. Если за этим макросом идет какой-то очищающий память код или какие-то другие завершающие процедуры, можно получить утечку памяти.\\
	
	Имеются следующие макросы:\\
	
	\assertiontype{Простейшие логические}
	
	\begin{itemize}
		\item \cppinline{ASSERT_TRUE(condition)};
		\item \cppinline{ASSERT_FALSE(condition)};
	\end{itemize}

	 Эти макросы позволяют проверять выражения на истенность или ложность. В качестве параметра condition должны передоваться простейшие логические выражения, возвращающие \cppinline{true} или \cppinline{false}.
	 
	 \cpplistingfromfile{logicalAssertion.cpp}
	 
	 Тем не менее, из-за того, что C++ воспринимает 0 как \cppinline{false}, а любые другие значения как \cppinline{true}, им можно передовать и значения, не принадлежащие типу \cppinline{bool}, но такие тесты не будут иметь смысла, поэтому для проверки не \cppinline{bool} типов, рекомендуется использовать следующие макросы.\\
	
	\assertiontype{Сравнение}
	
	\begin{itemize}
		\item \cppinline{ASSERT_EQ(val1, val2)}; --- ==
		\item \cppinline{ASSERT_NE(val1, val2)}; --- !=
		\item \cppinline{ASSERT_LT(val1, val2)}; --- <
		\item \cppinline{ASSERT_LE(val1, val2)}; --- <=
		\item \cppinline{ASSERT_GT(val1, val2)}; --- >
		\item \cppinline{ASSERT_GE(val1, val2)}; --- >=
	\end{itemize}
	
	Эти макросы позволяют сравнивать любые типы данных. В качестве параметров val1 и val2 передаются выражения, которые необходимо сравнить.
	
	\cpplistingfromfile{assertion.cpp}
	
	С помощью этих макросов можно сравнивать и строки, обходя их, например, циклом \cppinline{for}, но все же для этого рекомендуется пользоваться следующими специльными макросами.\\
	
	\assertiontype{Сравнение строк}
	
	\begin{itemize}
		\item \cppinline{ASSERT_STREQ(str1, str2)};
		\item \cppinline{ASSERT_STRNE(str1, str2)};
		\item \cppinline{ASSERT_STRCASEEQ(str1, str2)}; --- регистронезависимо
		\item \cppinline{ASSERT_STRCASENE(str1, str2)}; --- регистронезависимо
	\end{itemize}

	Эти макросы позволяют сравнить строки на равенство или неравенство, обходясь без лишних циклов. В качестве параметров str1 и str2 передаются строки, которые необходимо сравнить. Последние две отличаются от первых двух лишь тем, что они сравнивают строки независимо от регистра символов.
	
	\cpplistingfromfile{strAssertion.cpp}
	
	Также отдельные макросы есть для сравнения чисел с плавающей точкой (\cppinline{double, float}), так как часто бывает, что их значения совпадают в целой части и в начале десятичной, но потом начинают различаться, что приводит к ошибке в обычном числовом сравнении (\cppinline{ASSERT_EQ}).\\
	
	\assertiontype{Сравнение чисел с плавающей точкой}
	
	\begin{itemize}
		\item \cppinline{ASSERT_FLOAT_EQ(val1, val2)};
		\item \cppinline{ASSERT_DOUBLE_EQ(val1, val2)};
		\item \cppinline{ASSERT_NEAR(val1, val2, abs_error)};
	\end{itemize}

	Эти макросы позволяют сравнивать числа с плавающей точкой с некоторой погрешностью, а именно: \cppinline{ASSERT_FLOAT_EQ()} сравнивает до 8 знаков после запятой, \cppinline{ASSERT_DOUBLE_EQ()} - до 16 знаков и \cppinline{ASSERT_NEAR()} позволяет задать погрешность самостоятельно. В качестве параметров val1 и val2 передаются выражения, которые необходимо сравнить, а abs\_error - это погрешность сравнения.
	
	\cpplistingfromfile{floatAssertion.cpp}
	
	Помимо макросов для чисел и строк, есть и другие проверочные макросы.\\
	
	\assertiontype{Проверка на исключения}
	
	\begin{itemize}
		\item \cppinline{ASSERT_THROW(statement, exception_type)};
		\item \cppinline{ASSERT_ANY_THROW(statement)};
		\item \cppinline{ASSERT_NO_THROW(statement)};
	\end{itemize}

	Эти макросы позволяют проверить выражения на исключения (на какое-то конкретное, на любое или на их отсутствие). В качестве параметра statement передает проверяемое выражение, а exception\_type - какое исключение проверяется.
	
	\cpplistingfromfile{throwAssertion.cpp}
	
	\assertiontype{Проверка предикатов}
	
	\begin{itemize}
		\item \cppinline{ASSERT_PREDN(pred, val1, val2, ..., valN)} --- N <= 5
		\item \cppinline{ASSERT_PRED_FORMATN(pred_format, val1, val2, ..., valN)} --- аналогично, только позволяет контролировать вывод
	\end{itemize}

	Эти макросы позволяют проверить предикаты на истинность. В качестве параметра pred передается сам предикат, а val1, val2, ..., valN - аргументы, которые будут переданы предикату для проверки.

	\cpplistingfromfile{predAssertion.cpp}
	
	Также есть макросы, позволяющие генерировать успех, некритический отказ или критический отказ вручную.\\
	
	\assertiontype{Вызов отказа или успеха}
	
	\begin{itemize}
		\item \cppinline{SUCCEED()}; --- генерирует успех
		\item \cppinline{FAIL()}; --- генерирует критический отказ
		\item \cppinline{ADD_FAILURE()}; --- генерирует критический отказ
		\item \cppinline{ADD_FAILURE_AT(file_path, line_number)}; --- аналогично
	\end{itemize}

	Эти макросы не проверяют никаких выражений или значений. Вместо этого они генерируют успех или неудачу напрямую. В макросе\\ \cppinline{ADD_FAILURE_AT(file_path, line_number)}, параметр file\_path является строкой, а line\_number целым числом. Он позволяет сгенерировать ошибку с указанием имени файла и строки, на которой была ошибка.\\
	
	\assertiontype{Тесты смерти}
	
	Во многих приложениях есть утверждения, которые могут вызвать сбой приложения, если условие не выполняется. Эти проверки работоспособности, которые гарантируют, что программа находится в известном исправном состоянии, могут завершиться неудачей в кратчайшие возможные сроки после повреждения какого-либо состояния программы. Если утверждение проверяет неправильное условие, то программа может перейти в ошибочное состояние, что может привести к повреждению памяти, дырам в безопасности и т.д. Следовательно, жизненно важно проверить, работают ли такие утверждения как ожидается.\\
	
	Так как эти проверки предварительных условий приводят к смерти процессов, такие тесты называются тестами смерти. В более общем смысле, любой тест, который проверяет, что программа завершается (кроме как с помощью исключения) ожидаемым образом, также является тестом на смерть.
	
	Для создания тестов на смерть используются следующие макросы:
	
	\begin{itemize}
		\item \cppinline{ASSERT_DEATH(statement, regex)};
		\item \cppinline{ASSERT_DEATH_IF_SUPPORTED(statement, regex)};
		\item \cppinline{ASSERT_EXIT(statement, predicate, regex)};
	\end{itemize}

	В качестве параметра statement передается оператор, который, как ожидается, приведет к смерти процесса, predicate - это функция или функциональный объект, который оценивает целочисленное состояние выхода, а regex - это регулярное выражение, которому, как ожидается, будет соответствовать вывод оператора stderr. \cppinline{ASSERT_DEATH_IF_SUPPORTED(statement, regex)} проверяет, поддерживаются ли тесты на смерть и только потом проверяет оператор на заданную ошибку, иначе ничего не проверяет.
	
	\cpplistingfromfile{deathAssertion.cpp}
	
	\section{Фиксации(fixture)}
	
	Случается, что объекты, участвующие в тестировании, сложно настраиваются для каждого теста. Можно задать процесс настройки один раз и исполнять его для каждого теста автоматически. В таких ситуациях используются фиксации.\\
	
	Фиксация представляет собой класс, унаследованный от\\ \cppinline{::testing::Test}, внутри которого объявлены все необходимые для тестирования объекты при этом в конструкторе либо функции \cppinline{SetUp()} выполняется их настройка, а в функции \cppinline{TearDown()} освобождение ресурсов. Сами тесты, в которых используются фиксации, должны быть объявлены с помощью макроса \cppinline{TEST_F}, в качестве первого параметра которого должно быть указано не название набора тестов, а название фиксации.\\
	
	Для каждого теста будет создана новая фиксация, настроена с помощью \cppinline{SetUp()}, запущен тест, освобождены ресурсы с помощью \cppinline{TearDown()} и удален объект фиксации. Таким образом каждый тест будет иметь свою копию фиксации «не испорченную» предыдущим тестом.
	
	\cpplistingfromfile{fixture.cpp}
	
	В некоторых случаях создание тестируемых объектов является очень дорогой операцией, а тесты не вносят никаких изменений в объекты. В таком случае можно не создавать фиксации заново для каждого теста, а использовать распределенную фиксацию с глобальным \cppinline{SetUp()}и \cppinline{TearDown()}. Фиксация автоматически становится распределенной, если в классе имеется хотя бы один статический член. Статические функции \cppinline{SetUpTestCase()} и \cppinline{TearDownTestCase()} будут вызываться для настройки объекта и освобождения ресурсов соответственно. Таким образом, набор тестов перед первым тестом вызовет \cppinline{SetUpTestCase()}, а после последнего \cppinline{TearDownTestCase()}.
	
	\cpplistingfromfile{staticFixture.cpp}
	
	\section{Запуск тестов}
	
	Объявив все необходимые тесты, мы можем запустить их с помощью функции \cppinline{RUN_ALL_TESTS()}. Функцию можно вызывать только один раз. Желательно, чтобы тестовая программа возвращала результат работы функции \cppinline{RUN_ALL_TESTS()}, так как некоторые автоматические средства тестирования определяют результат выполнения тестовой программы по тому, что она возвращает. Перед \cppinline{RUN_ALL_TESTS()} следует вызывать функцию \cppinline{InitGoogleTest(&argc, argv)}. Таким образом, ваша тестовая программа будет не просто исполняемым файлом, выводящим на экран результаты тестирования, а целостным приложением, принимающим на вход параметры, меняющие его поведение.\\
	
	Таким образом, запуск тестов должен иметь следующий вид:
	
	\cpplistingfromfile{startTesting.cpp}
\end{document}